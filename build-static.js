#!/usr/bin/env node
/**
 * Build script to bundle static files into the Worker
 * This reads files from the public/ directory and embeds them in the index.js
 */

const fs = require('fs');
const path = require('path');

// MIME type mappings
const MIME_TYPES = {
  '.html': 'text/html',
  '.htm': 'text/html',
  '.css': 'text/css',
  '.js': 'application/javascript',
  '.json': 'application/json',
  '.png': 'image/png',
  '.jpg': 'image/jpeg',
  '.jpeg': 'image/jpeg',
  '.gif': 'image/gif',
  '.svg': 'image/svg+xml',
  '.ico': 'image/x-icon',
  '.txt': 'text/plain',
  '.xml': 'application/xml',
  '.pdf': 'application/pdf',
  '.woff': 'font/woff',
  '.woff2': 'font/woff2',
  '.ttf': 'font/ttf',
  '.otf': 'font/otf'
};

function getMimeType(filePath) {
  const ext = path.extname(filePath).toLowerCase();
  return MIME_TYPES[ext] || 'application/octet-stream';
}

function readFilesRecursively(dir, baseDir = dir) {
  const files = {};
  
  if (!fs.existsSync(dir)) {
    console.log(`Directory ${dir} does not exist, skipping...`);
    return files;
  }
  
  const entries = fs.readdirSync(dir, { withFileTypes: true });
  
  for (const entry of entries) {
    const fullPath = path.join(dir, entry.name);
    const relativePath = path.relative(baseDir, fullPath).replace(/\\/g, '/');
    
    if (entry.isDirectory()) {
      Object.assign(files, readFilesRecursively(fullPath, baseDir));
    } else {
      const content = fs.readFileSync(fullPath);
      const mimeType = getMimeType(fullPath);
      
      // For binary files, convert to base64
      const isBinary = !mimeType.startsWith('text/') && 
                      !mimeType.includes('javascript') && 
                      !mimeType.includes('json') &&
                      !mimeType.includes('xml') &&
                      !mimeType.includes('svg');
      
      files[`/${relativePath}`] = {
        content: isBinary ? content.toString('base64') : content.toString('utf8'),
        mimeType: mimeType,
        isBinary: isBinary
      };
    }
  }
  
  return files;
}

function generateStaticFilesObject() {
  const publicFiles = readFilesRecursively('./public');
  
  let output = 'const STATIC_SITE_FILES = {\n';
  
  for (const [filePath, fileData] of Object.entries(publicFiles)) {
    const escapedContent = JSON.stringify(fileData.content);
    output += `  '${filePath}': {\n`;
    output += `    content: ${escapedContent},\n`;
    output += `    mimeType: '${fileData.mimeType}',\n`;
    output += `    isBinary: ${fileData.isBinary}\n`;
    output += `  },\n`;
  }
  
  output += '};\n\n';
  
  // Add helper function
  output += `function getStaticFile(path) {
  // Normalize path
  let normalizedPath = path;
  
  // Handle directory requests - look for index.html
  if (normalizedPath.endsWith('/') || normalizedPath === '') {
    normalizedPath = normalizedPath === '' ? '/index.html' : normalizedPath + 'index.html';
  }
  
  // If no extension, try adding .html
  if (!path.includes('.') && !STATIC_SITE_FILES[normalizedPath]) {
    normalizedPath = normalizedPath + '.html';
  }
  
  const file = STATIC_SITE_FILES[normalizedPath];
  if (!file) return null;
  
  let content;
  if (file.isBinary) {
    // Convert base64 back to binary for response
    const binaryString = atob(file.content);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i++) {
      bytes[i] = binaryString.charCodeAt(i);
    }
    content = bytes;
  } else {
    content = file.content;
  }
  
  return {
    content: content,
    mimeType: file.mimeType,
    isBinary: file.isBinary
  };
}\n\n`;
  
  return output;
}

function updateIndexJS() {
  const indexJsPath = './index.js';
  
  if (!fs.existsSync(indexJsPath)) {
    console.error('index.js not found!');
    process.exit(1);
  }
  
  let indexContent = fs.readFileSync(indexJsPath, 'utf8');
  const newStaticFilesCode = generateStaticFilesObject();
  
  // Find the start and end of the STATIC_SITE_FILES section
  const startMarker = '// Static site files bundle (generated by build-static.js)';
  const endMarker = 'function getStaticFile(path) {';
  
  const startIndex = indexContent.indexOf(startMarker);
  const endIndex = indexContent.indexOf(endMarker);
  
  if (startIndex === -1 || endIndex === -1) {
    console.error('Could not find STATIC_SITE_FILES section in index.js');
    console.log('Please ensure the file has the correct markers');
    process.exit(1);
  }
  
  // Find the end of the getStaticFile function
  const functionEnd = indexContent.indexOf('\n}\n\n', endIndex) + 4;
  
  // Replace the section
  const newContent = 
    indexContent.substring(0, startIndex) +
    startMarker + '\n' +
    newStaticFilesCode +
    indexContent.substring(functionEnd);
  
  fs.writeFileSync(indexJsPath, newContent);
  console.log('✅ Updated index.js with new static files bundle');
}

// Generate the static files object
const publicFiles = readFilesRecursively('./public');

console.log('🔍 Building static files bundle...');
console.log(`📁 Found ${Object.keys(publicFiles).length} files in public/ directory:`);

Object.keys(publicFiles).forEach(file => {
  const fileData = publicFiles[file];
  console.log(`   ${file} (${fileData.mimeType})`);
});

// Save to a separate file for reference
const staticFilesCode = generateStaticFilesObject();
fs.writeFileSync('./static-files.js', staticFilesCode);
console.log('📄 Static files bundle saved to static-files.js');

// Update index.js directly
updateIndexJS();

console.log('🎉 Build complete! Static site is ready for deployment.');